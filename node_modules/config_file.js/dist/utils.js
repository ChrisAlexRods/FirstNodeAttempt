"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.moveFile = exports.move = exports.renameKeys = exports.separateByValue = exports.generateUuid = exports.bindOptions = void 0;
const fs_1 = __importDefault(require("fs"));
/**
 * @param defaultOptions
 * @param options
 */
function bindOptions(defaultOptions, options) {
    if (!options)
        return defaultOptions;
    if (!defaultOptions)
        return options;
    // TODO: use structuredClone
    const result = Object.assign({}, defaultOptions);
    const nullPath = getNullPath(defaultOptions);
    for (const option of getValuesWithPath(options, [], nullPath)) {
        const { path, value } = option;
        // もしパスが途中で途切れていたら、その奥は直接コピーする
        if (!hasPath(result, path)) {
            for (let i = 0; i < path.length; i++) {
                const checkPath = path.slice(0, i + 1);
                if (!hasPath(result, checkPath)) {
                    const resultPath = checkPath.slice(0, -1);
                    if (getPath(result, resultPath) === null) {
                        resultPath.pop();
                        const object = resultPath.reduce((acc, key) => acc[key], result);
                        const adjustPath = path.slice(i - 1);
                        const key = adjustPath.pop();
                        setPath(object, adjustPath, { [key]: value });
                        break;
                    }
                    else {
                        const object = resultPath.reduce((acc, key) => acc[key], result);
                        setPath(object, path.slice(i), value);
                        break;
                    }
                }
            }
        }
        else {
            const last = path.pop();
            const object = path.reduce((acc, key) => acc[key], result);
            object[last] = value;
        }
    }
    return result;
}
exports.bindOptions = bindOptions;
/**
 * Get the path where the value is null, or undefined.
 */
function getNullPath(object, path = []) {
    const result = [];
    for (const key in object) {
        const value = object[key];
        const newPath = [...path, key];
        if (typeof value === "object" && !Array.isArray(value) && value !== null && value !== undefined) {
            result.push(...getNullPath(value, newPath));
        }
        else if (value === null || value === undefined) {
            result.push(newPath);
        }
    }
    return result;
}
/**
 * Warning: This function will not work with circular object.
 */
function getValuesWithPath(object, path = [], defaultOptionsNullPath = []) {
    const result = [];
    for (const key in object) {
        const value = object[key];
        const newPath = [...path, key];
        if (defaultOptionsNullPath.length !== 0) {
            if (defaultOptionsNullPath.some(p => p.every((v, i) => v === newPath[i]) && newPath.length === p.length)) {
                result.push({ path: newPath, value: value });
                continue;
            }
        }
        if (typeof value === "object" && !Array.isArray(value) && value !== null && value !== undefined) {
            result.push(...getValuesWithPath(value, newPath, defaultOptionsNullPath));
        }
        else {
            result.push({ path: newPath, value: value });
        }
    }
    return result;
}
function getPath(object, path) {
    const last = path.pop();
    for (const key of path) {
        if (!Object.keys(object).includes(key)) {
            return undefined;
        }
        object = object[key];
    }
    return object[last];
}
function hasPath(object, path) {
    for (const key of path) {
        if (typeof object !== "object" || object === null)
            return false;
        if (!Object.keys(object).includes(key)) {
            return false;
        }
        object = object[key];
    }
    return true;
}
function setPath(object, path, value) {
    const last = path.pop();
    for (const key of path) {
        if (Object.keys(object).includes(key)) {
            object = object[key];
        }
        else {
            object[key] = {};
            object = object[key];
        }
    }
    object[last] = value;
}
/** Generates random uuid v4 */
function generateUuid() {
    const chars = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".split("");
    for (let i = 0; i < chars.length; i++) {
        switch (chars[i]) {
            case "x":
                chars[i] = Math.floor(Math.random() * 16).toString(16);
                break;
            case "y":
                chars[i] = (Math.floor(Math.random() * 4) + 8).toString(16);
                break;
        }
    }
    return chars.join("");
}
exports.generateUuid = generateUuid;
/**
 * @param array
 * @param callback
 */
function separateByValue(array, callback) {
    const result = {};
    for (const element of array) {
        const value = callback(element);
        if (!result[value])
            result[value] = [];
        result[value].push(element);
    }
    return result;
}
exports.separateByValue = separateByValue;
/**
 * @param obj
 * @param newKeys
 */
function renameKeys(obj, newKeys) {
    const keyValues = Object.keys(obj).map(key => {
        const newKey = newKeys[key] || key;
        return { [newKey]: obj[key] };
    });
    return Object.assign({}, ...keyValues);
}
exports.renameKeys = renameKeys;
/**
 * @param dirFrom
 * @param dirTo
 */
function move(dirFrom, dirTo) {
    const files = fs_1.default.readdirSync(dirFrom);
    for (const file of files) {
        const loadedFile = fs_1.default.lstatSync(`${dirFrom}/${file}`);
        if (loadedFile.isDirectory()) {
            if (!fs_1.default.existsSync(`${dirTo}/${file}`))
                fs_1.default.mkdirSync(`${dirTo}/${file}`);
            move(`${dirFrom}/${file}`, `${dirTo}/${file}`);
            fs_1.default.rmdirSync(`${dirFrom}/${file}`, { maxRetries: 3 });
        }
        else {
            moveFile(`${dirFrom}/${file}`, `${dirTo}/${file}`);
        }
    }
}
exports.move = move;
/**
 * @param fileFrom
 * @param fileTo
 */
function moveFile(fileFrom, fileTo) {
    fs_1.default.renameSync(fileFrom, fileTo);
}
exports.moveFile = moveFile;
